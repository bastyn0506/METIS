import logging
import logging.handlers
import requests
import json
import os
import threading
import time
import geoip2.database
from scapy.all import sniff, IP, TCP, UDP, Raw
from collections import defaultdict
from datetime import datetime

# Unity„ÅÆHTTPÂèó‰ø°„Çµ„Éº„Éê„ÉºURL
UNITY_SERVER_URL = "http://localhost:8765"
INTERFACE = "\\Device\\NPF_{23FE3796-0B4B-461E-999E-C711816C4C61}" #BAE165C8-FDF3-18C9-8019-307924B0EE9E(server)  23FE3796-0B4B-461E-999E-C711816C4C61(pc)


# ÈÄö‰ø°Áµ±Ë®à‰øùÊåÅÁî®
port_traffic = defaultdict(int)  # „Éù„Éº„ÉàÂà•ÈÄö‰ø°ÈáèÔºà„Éë„Ç±„ÉÉ„ÉàÊï∞Ôºâ
port_ip_traffic = defaultdict(lambda: defaultdict(int))  # „Éù„Éº„Éà√óIPÂà•ÈÄö‰ø°Êï∞
ip_traffic = defaultdict(int)  # {IP„Ç¢„Éâ„É¨„Çπ: ÈÄö‰ø°ÂõûÊï∞}
# IP„Ç¢„Éâ„É¨„Çπ„Åî„Å®„ÅÆÂõΩÂêç‰øùÂ≠òÁî®
ip_country = {}
# „Çπ„Ç≠„É£„É≥Ê§úÂá∫„Éá„Éº„Çø
scan_detection = defaultdict(lambda: {"ports": set(), "last_time": 0})
last_stats_send_time = 0
last_mtime = 0
syslog_logger = logging.getLogger("METIS-Syslog")
syslog_logger.setLevel(logging.INFO)
handler = logging.handlers.SysLogHandler(address=("localhost", 514), facility=logging.handlers.SysLogHandler.LOG_USER)
syslog_logger.addHandler(handler)


lock = threading.Lock()

# üîß config.json Ë™≠„ÅøËæº„Åø„Å®Áõ£Ë¶ñÁî®
config = {}
config_path = r"C:\Users\nakah\Desktop\metis\config.json"
config_lock = threading.Lock()
last_sent_danger_ports = []

def send_syslog_alert(message: str):
    syslog_logger.info(message)

def send_danger_ports_to_unity():               #Unity„Å´Âç±Èô∫„Éù„Éº„Éà„ÅÆ„É™„Çπ„Éà„ÇíÈÄÅ‰ø°„ÄÇ
    try:
        with config_lock:
            ports = config.get("dangerous_ports", [])
        headers = {"Content-Type": "application/json"}
        payload = {
            "type": "danger_ports_update",
            "ports": ports
        }
        response = requests.post(UNITY_SERVER_URL, json=payload, headers=headers, timeout=3)
    except Exception as e:
        print(f"[!] Âç±Èô∫„Éù„Éº„ÉàÈÄÅ‰ø°„Ç®„É©„Éº: {e}")
                 
def load_config():                               #config.json „ÇíË™≠„ÅøËæº„Çì„Åß„ÄÅPythonÂÅ¥„Å´Ë®≠ÂÆöÂèçÊò†
    global config
    try:
        with open(config_path, "r") as f:
            new_config = json.load(f)
            new_config["dangerous_ports"] = [int(p) for p in new_config.get("dangerous_ports", [])]
            new_config["scan_threshold_ports"] = int(new_config.get("scan_threshold_ports", 3))
            new_config["scan_threshold_seconds"] = int(new_config.get("scan_threshold_seconds", 10))
            with config_lock:
                config = new_config
            print(f"[‚úì] Ë®≠ÂÆöÂÜçË™≠„ÅøËæº„Åø: {config}")
            send_danger_ports_to_unity()
    except Exception as e:
        print(f"[!] Ë®≠ÂÆöË™≠„ÅøËæº„Åø„Ç®„É©„Éº: {e}")


def config_watcher(interval=5):                   #config.json „ÅÆÊõ¥Êñ∞ÊôÇÂàª„ÇíÂÆöÊúü„ÉÅ„Çß„ÉÉ„ÇØ„Åó„Å¶„ÄÅÂ§âÊõ¥„Åå„ÅÇ„Çå„Å∞ load_config() „ÇíÂëº„Å∂
    global last_sent_danger_ports, last_mtime
    while True:
        try:
            current_mtime = os.path.getmtime(config_path)
            if current_mtime != last_mtime:
                last_mtime = current_mtime

                # ‚úÖ Ë®≠ÂÆö„ÇíÂÜçË™≠„ÅøËæº„Åø
                load_config()
                print("[‚úì] config.json „Å´Â§âÊõ¥„ÅÇ„Çä ‚Üí ÂÜçË™≠„ÅøËæº„Åø")

                with config_lock:
                    danger_ports = config.get("dangerous_ports", [])
                if danger_ports != last_sent_danger_ports:
                    send_danger_ports_to_unity()
                    last_sent_danger_ports = danger_ports.copy()

        except Exception as e:
            print(f"[!] Ë®≠ÂÆöÁõ£Ë¶ñ‰∏≠„Ç®„É©„Éº: {e}")

        time.sleep(interval)



# ‚úÖ Ëµ∑ÂãïÊôÇ„ÅÆÂàùÂõûË™≠„ÅøËæº„ÅøÔºã„Çπ„É¨„ÉÉ„ÉâËµ∑Âãï
load_config()
threading.Thread(target=config_watcher, daemon=True).start()




def save_log(data, log_dir='logs'):         #JSONÂΩ¢Âºè„Åß„É≠„Ç∞„Çí logs/packet_log_YYYYMMDD.jsonl „Å´ËøΩË®ò‰øùÂ≠ò
    base_dir = os.path.dirname(os.path.abspath(__file__))  # ‰ªäÂãï„Åã„Åó„Å¶„Çã.py„ÅÆÂ†¥ÊâÄ
    log_dir = os.path.join(base_dir, "logs")
    os.makedirs(log_dir, exist_ok=True) # „É≠„Ç∞„Éá„Ç£„É¨„ÇØ„Éà„É™„Åå„Å™„Åë„Çå„Å∞‰Ωú„Çã

    # „Éï„Ç°„Ç§„É´Âêç„ÇíÊó•‰ªò„Åî„Å®„Å´Â§â„Åà„Çã
    date_str = datetime.now().strftime("%Y%m%d")
    log_path = os.path.join(log_dir, f"packet_log_{date_str}.jsonl")

    # 1Ë°å„Åö„Å§JSON„ÅßËøΩË®ò„É¢„Éº„Éâ
    with open(log_path, 'a', encoding='utf-8') as f:
        json.dump(data, f, ensure_ascii=False)
        f.write('\n')
    print(f"[‚úì] „É≠„Ç∞‰øùÂ≠òÊàêÂäü: {log_path}")



def send_packet_to_unity(packet_data):                 #Unity„Å´1„Éë„Ç±„ÉÉ„Éà„ÅÆË©≥Á¥∞Ôºàsrc, dst, size, protocol, port„Å™„Å©Ôºâ„ÇíÈÄÅ‰ø°
    try:
        headers = {"Content-Type": "application/json"}
        response = requests.post(UNITY_SERVER_URL, json=packet_data, headers=headers)
        print(f"[‚úì] ÈÄÅ‰ø°: {packet_data['src']} ‚Üí {packet_data['dst']} | „Çπ„ÉÜ„Éº„Çø„Çπ: {response.status_code}")
    except Exception as e:
        print(f"[!] ÈÄÅ‰ø°„Ç®„É©„Éº: {e}")


def send_live_packet_to_unity(src_ip, dst_ip):
    try:
        payload = {
            "type": "live_packet",
            "src": src_ip,
            "dst": dst_ip
        }
        headers = {"Content-Type": "application/json"}
        response = requests.post(UNITY_SERVER_URL, json=payload, headers=headers, timeout=2)
        print(f"[LIVE] „Éë„Ç±„ÉÉ„ÉàÈÄöÁü•: {src_ip} -> {dst_ip} | „Çπ„ÉÜ„Éº„Çø„Çπ: {response.status_code}")
    except Exception as e:
        print(f"[!] „É©„Ç§„Éñ„Éë„Ç±„ÉÉ„ÉàÈÄÅ‰ø°„Ç®„É©„Éº: {e}")

        
def send_scan_alert_to_unity(ip):               #„Éù„Éº„Éà„Çπ„Ç≠„É£„É≥„ÇíÊ§úÁü•„Åó„ÅüÊôÇ„Å´Unity„Å∏Ë≠¶Âëä„Éá„Éº„Çø„ÇíÈÄÅ„Çã„ÄÇ    
    try:
        headers = {"Content-Type": "application/json"}
        alert_data = {
            "type": "scan_alert",
            "src_ip": ip
        }
        response = requests.post(UNITY_SERVER_URL, json=alert_data, headers=headers)
        print(f"[üö®] „Çπ„Ç≠„É£„É≥„Ç¢„É©„Éº„ÉàÈÄÅ‰ø°: {ip} | „Çπ„ÉÜ„Éº„Çø„Çπ: {response.status_code}")

        alert_log = {
            "timestamp": datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
            "type": "scan_detected",
            "src_ip": ip,
            "dst_ip": None,
            "protocol": None,
            "src_port": None,
            "dst_port": None,
            "size": 0,
            "country": get_country(ip),
            "alert": "Port scan detected"
        }
        save_log(alert_log)
        send_syslog_alert(f"METIS Alert: Port scan detected from {ip}")
    except Exception as e:
        print(f"[!] „Çπ„Ç≠„É£„É≥„Ç¢„É©„Éº„ÉàÈÄÅ‰ø°„Ç®„É©„Éº: {e}")
    
reader = geoip2.database.Reader(r'C:\Users\nakah\Desktop\metis\GeoLite2-Country_20250404\GeoLite2-Country.mmdb')
def get_country(ip):        #GeoIP„Éá„Éº„Çø„Éô„Éº„Çπ„Çí‰Ωø„Å£„Å¶„ÄÅIP„Ç¢„Éâ„É¨„Çπ„ÅÆÂõΩÂêç„ÇíÂèñÂæó
    try:
        response = reader.country(ip)
        return response.country.name
    except:
        return "Unknown"

def packet_callback(packet):                       #Scapy„Åå„Ç≠„É£„Éó„ÉÅ„É£„Åó„Åü„Éë„Ç±„ÉÉ„Éà„ÇíËß£Êûê„ÉªË®òÈå≤„ÉªÈÄÅ‰ø°„Åô„Çã„É°„Ç§„É≥Âá¶ÁêÜ„ÄÇÂç±Èô∫„Éù„Éº„Éà/„Çπ„Ç≠„É£„É≥Ê§úÁü•/Áµ±Ë®àÂèéÈõÜ„Å™„Å©ÂÖ®ÈÉ®„Åì„Åì„Åß„ÇÑ„Çã
    try:
        if IP in packet:
            src_ip = packet[IP].src
            dst_ip = packet[IP].dst

            send_live_packet_to_unity(src_ip, dst_ip)

            dport = None
            protocol = "Other"

            if packet.haslayer(TCP):
                protocol = "TCP"
                dport = packet[TCP].dport
            elif packet.haslayer(UDP):
                protocol = "UDP"
                dport = packet[UDP].dport

            size = len(packet)

            if dport is not None:
                if src_ip not in scan_detection:
                    scan_detection[src_ip] = {"ports": set(), "last_time": time.time()}

                scan_detection[src_ip]["ports"].add(dport)
                scan_detection[src_ip]["last_time"] = time.time()

            src_port = packet[TCP].sport if TCP in packet else (packet[UDP].sport if UDP in packet else None)
            dst_port = packet[TCP].dport if TCP in packet else (packet[UDP].dport if UDP in packet else None)

            with config_lock:
                dangerous_ports = set(config.get("dangerous_ports", [23, 445, 3389]))

                print(f"[„Éá„Éê„ÉÉ„Ç∞] {src_ip} „ÅÆ„Éù„Éº„ÉàË®òÈå≤: {scan_detection[src_ip]['ports']}")
                scan_threshold_seconds = int(config.get("scan_threshold_seconds", 20))
                scan_threshold_ports = int(config.get("scan_threshold_ports", 3))

                print(f"[„Éá„Éê„ÉÉ„Ç∞] {src_ip} „ÅÆ„Éù„Éº„ÉàË®òÈå≤: {scan_detection[src_ip]['ports']}")

            if dst_port in dangerous_ports:
                print(f"[‚ö†Ô∏è] Âç±Èô∫„Éù„Éº„Éà {dst_port} „Å∏„ÅÆ„Ç¢„ÇØ„Çª„ÇπÊ§úÁü•ÔºÅ")

                danger_alert_log = {
                    "timestamp": datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
                    "type": "dangerous_port_detected",
                    "src_ip": src_ip,
                    "dst_ip": dst_ip,
                    "protocol": protocol,
                    "src_port": src_port,
                    "dst_port": dst_port,
                    "size": size,
                    "country": get_country(src_ip),
                    "alert": f"Access to dangerous port {dst_port}"
                }            
                save_log(danger_alert_log)

            payload = packet[Raw].load.hex() if Raw in packet else None

            now = time.time()
            if dst_port:
                data = scan_detection[src_ip]

                if now - data["last_time"] > scan_threshold_seconds:
                    data["ports"].clear()

                data["ports"].add(dst_port)
                data["last_time"] = now

                if len(data["ports"]) > scan_threshold_ports:
                    print(f"[‚ö†Ô∏è] „Çπ„Ç≠„É£„É≥Ê§úÁü•: {src_ip}")
                    send_scan_alert_to_unity(src_ip)
                    data["ports"].clear()

            src_country = get_country(src_ip)
            dst_country = get_country(dst_ip)

            with lock:
                if src_ip not in ip_country:
                    ip_country[src_ip] = src_country
                if dst_ip not in ip_country:
                    ip_country[dst_ip] = dst_country

                print(f"[TRACK] dst_port = {dst_port} (type: {type(dst_port)})")

                if dst_port:
                    port_traffic[dst_port] += 1
                    print(f"[‚úÖ] port_traffic[{dst_port}] = {port_traffic[dst_port]}")
                    port_ip_traffic[dst_port][src_ip] += 1
                else:
                    ip_traffic[src_ip] += 1
                    ip_traffic[dst_ip] += 1

            packet_data = {
                "type": "packet",
                "src": src_ip,
                "dst": dst_ip,
                "src_country": src_country,
                "dst_country": dst_country,
                "protocol": protocol,
                "size": size,
                "src_port": src_port,
                "dst_port": dst_port,
                "payload": payload
            }
            send_packet_to_unity(packet_data)
            save_log(packet_data)

            global last_stats_send_time
            if now - last_stats_send_time >= 1:
                send_port_ip_stats()
                last_stats_send_time = now

    except Exception as e:
        print(f"[‚ùå] packet_callback ÂÜÖ„Åß‰æãÂ§ñÁô∫Áîü: {e}")





def send_port_ip_stats():     #ÂêÑ„Éù„Éº„Éà„Å®IP„Åî„Å®„ÅÆÁµ±Ë®à„ÇíUnity„Å´ÈÄÅ‰ø°
    try:
        with lock:
            # Áµ±Ë®à„Éá„Éº„Çø„ÅÆ„Éá„Ç£„Éº„Éó„Ç≥„Éî„ÉºÔºàÈÄÅ‰ø°‰∏≠„ÅÆÂ§âÊõ¥Èò≤Ê≠¢Ôºâ
            stats_copy = {port: dict(ip_counts) for port, ip_counts in port_ip_traffic.items()}
        print(f"[„Éá„Éê„ÉÉ„Ç∞] port_ip_traffic ÁèæÂú®„ÅÆÂÜÖÂÆπ: {stats_copy}")
        
        payload = {
            "type": "port_ip_stats",
            "port_ip_counts": stats_copy
        }

        headers = {"Content-Type": "application/json"}
        response = requests.post(UNITY_SERVER_URL, json=payload, headers=headers)

        print(f"[üì§] „Éù„Éº„Éà√óIPÁµ±Ë®àÈÄÅ‰ø°: {len(stats_copy)}‰ª∂ | „Çπ„ÉÜ„Éº„Çø„Çπ: {response.status_code}")
    except Exception as e:
        print(f"[!] „Éù„Éº„ÉàÁµ±Ë®àÈÄÅ‰ø°„Ç®„É©„Éº: {e}")



  
def send_stats_periodically(interval=5):        #5Áßí„Åä„Åç„Å´ÈÄö‰ø°Áµ±Ë®àÔºà„Éù„Éº„ÉàÊï∞„ÄÅIPÊï∞„Å™„Å©Ôºâ„Çí„Åæ„Å®„ÇÅ„Å¶Unity„Å∏ÈÄÅ„Çã
    headers = {"Content-Type": "application/json"}
    while True:
        time.sleep(interval)

        # ‚òÖ „Åì„Åì„Åß„Éá„Éº„Çø‰Ωú„ÇãÔºà„É≠„ÉÉ„ÇØ‰∏≠Ôºâ
        with lock:
            stats_data = {
                "type": "port_stats",
                "port_counts": dict(port_traffic)
            }
            port_traffic.clear()

            send_ip_stats = {}
            for port, ip_counts in port_ip_traffic.items():
                send_ip_stats[port] = dict(ip_counts)

            ip_ports = {}
            for port, ip_counts in port_ip_traffic.items():
                for ip in ip_counts:
                    if ip not in ip_ports:
                        ip_ports[ip] = set()
                    ip_ports[ip].add(port)

            port_ip_traffic.clear()

        # ‚òÖ „É≠„ÉÉ„ÇØÊäú„Åë„Åü„ÅÇ„Å®„Å´ÈÄÅ‰ø°ÈñãÂßã

        # ÈÄÅ‰ø°‚ë†: „Éù„Éº„Éà„Åî„Å®„ÅÆ„Éë„Ç±„ÉÉ„ÉàÊï∞
        try:
            response = requests.post(UNITY_SERVER_URL, json=stats_data, headers=headers)
            print(f"[‚òÖ] „Éù„Éº„ÉàÁµ±Ë®àÈÄÅ‰ø°: {len(stats_data['port_counts'])}‰ª∂")
        except Exception as e:
            print(f"[!] „Éù„Éº„ÉàÁµ±Ë®àÈÄÅ‰ø°„Ç®„É©„Éº: {e}")

        # ÈÄÅ‰ø°‚ë°: „Éù„Éº„Éà√óIPÁµ±Ë®à
        try:
            if send_ip_stats:

                print("[„Éá„Éê„ÉÉ„Ç∞] ÈÄÅ‰ø°„Åô„Çã„Éù„Éº„Éà√óIPÁµ±Ë®à:")
                print(json.dumps(send_ip_stats, indent=2))
                port_ip_data = {
                    "type": "port_ip_stats",
                    "port_ip_counts": send_ip_stats
                }
                response = requests.post(UNITY_SERVER_URL, json=port_ip_data, headers=headers)
                print(f"[‚òÖ] „Éù„Éº„Éà√óIPÁµ±Ë®àÈÄÅ‰ø°: {len(port_ip_data['port_ip_counts'])}‰ª∂")
        except Exception as e:
            print(f"[!] „Éù„Éº„Éà√óIPÁµ±Ë®àÈÄÅ‰ø°„Ç®„É©„Éº: {e}")

        # ÈÄÅ‰ø°‚ë¢: IP„Åî„Å®„ÅÆ‰ΩøÁî®„Éù„Éº„Éà‰∏ÄË¶ß
        try:
            if ip_ports:
                ip_port_data = {
                    "type": "ip_port_stats",
                    "ip_ports": {ip: list(ports) for ip, ports in ip_ports.items()}
                }
                response = requests.post(UNITY_SERVER_URL, json=ip_port_data, headers=headers)
                print(f"[üåê] IP√ó„Éù„Éº„ÉàÊÉÖÂ†±ÈÄÅ‰ø°: {len(ip_port_data['ip_ports'])}‰ª∂")
        except Exception as e:
            print(f"[!] IP√ó„Éù„Éº„ÉàÊÉÖÂ†±ÈÄÅ‰ø°„Ç®„É©„Éº: {e}")

        # ÈÄÅ‰ø°‚ë£: IP„Åî„Å®„ÅÆÈÄö‰ø°ÂõûÊï∞
        try:
            if ip_traffic:
                ip_traffic_data = {
                    "type": "ip_traffic_stats",
                    "ip_traffic_counts": dict(ip_traffic)
                }
                response = requests.post(UNITY_SERVER_URL, json=ip_traffic_data, headers=headers)
                print(f"[üìà] IPÈÄö‰ø°ÂõûÊï∞ÈÄÅ‰ø°: {len(ip_traffic_data['ip_traffic_counts'])}‰ª∂")
                ip_traffic.clear()  # ÈÄÅ‰ø°Âæå„É™„Çª„ÉÉ„Éà
        except Exception as e:
            print(f"[!] IPÈÄö‰ø°ÂõûÊï∞ÈÄÅ‰ø°„Ç®„É©„Éº: {e}")

        # ÈÄÅ‰ø°‚ë§: IP„Åî„Å®„ÅÆÂõΩÂêçÊÉÖÂ†±
        try:
            if ip_country:
                ip_country_data = {
                    "type": "ip_country_stats",
                    "ip_countries": dict(ip_country)
                }
                response = requests.post(UNITY_SERVER_URL, json=ip_country_data, headers=headers)
                print(f"[üåé] IPÂõΩÂêçÊÉÖÂ†±ÈÄÅ‰ø°: {len(ip_country_data['ip_countries'])}‰ª∂")
                ip_country.clear()  # ÈÄÅ‰ø°Âæå„É™„Çª„ÉÉ„Éà
        except Exception as e:
            print(f"[!] IPÂõΩÂêçÈÄÅ‰ø°„Ç®„É©„Éº: {e}")



def start_sniffing():                                             #„Éë„Ç±„ÉÉ„Éà„Çπ„Éã„Éï„Ç°„Éº„ÇíÈñãÂßã„ÄÇpacket_callback() „Çí„É™„Ç¢„É´„Çø„Ç§„É†„ÅßÂëº„Å≥Á∂ö„Åë„Çã
    print(f"[*] „É™„Ç¢„É´„Çø„Ç§„É†„Åß„Éë„Ç±„ÉÉ„Éà„ÇíÈÄÅ‰ø°„Åó„Åæ„ÅôÔºàCtrl+C„ÅßÁµÇ‰∫ÜÔºâ")

    # Áµ±Ë®àÈÄÅ‰ø°„Çπ„É¨„ÉÉ„ÉâÈñãÂßã
    stats_thread = threading.Thread(target=send_stats_periodically, daemon=True)
    stats_thread.start()

    sniff(prn=packet_callback, store=False, iface=INTERFACE)

if __name__ == "__main__":
    save_log({
        "timestamp": datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
        "test": "ÂàùÊúüÂãï‰ΩúÁ¢∫Ë™ç„É≠„Ç∞"
     })
    start_sniffing()






